
// ฟังก์ชันช่วย: ตรวจสอบว่าเป็นตัวอักษร (A-Z, a-z) หรือตัวเลข (0-9) หรือไม่
// คืนค่า 1 ถ้าใช่, 0 ถ้าไม่ใช่
int ft_is_alphanumeric(char c)
{
    if ((c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9'))
    {
        return 1;
    }
    return 0;
}

// ฟังก์ชันช่วย: แปลงตัวพิมพ์เล็กเป็นตัวพิมพ์ใหญ่
// คืนค่าอักขระที่ถูกแปลงแล้ว หรืออักขระเดิมหากไม่ใช่ตัวพิมพ์เล็ก
char ft_to_upper(char c)
{
    if (c >= 'a' && c <= 'z')
    {
        return c - 32; // 'A' - 'a' = -32
    }
    return c;
}

// ฟังก์ชันช่วย: แปลงตัวพิมพ์ใหญ่เป็นตัวพิมพ์เล็ก
// คืนค่าอักขระที่ถูกแปลงแล้ว หรืออักขระเดิมหากไม่ใช่ตัวพิมพ์ใหญ่
char ft_to_lower(char c)
{
    if (c >= 'A' && c <= 'Z')
    {
        return c + 32; // 'a' - 'A' = 32
    }
    return c;
}

// ฟังก์ชันหลัก: แปลงสตริงให้ตัวอักษรตัวแรกของแต่ละคำเป็นตัวพิมพ์ใหญ่
char *ft_strcapitalize(char *str)
{
    int i;
    // ใช้ 'is_start_of_word' เป็นแฟล็ก (1 = true, 0 = false)
    // บอกว่าอักขระปัจจุบันควรถูกพิจารณาเป็นตัวแรกของคำหรือไม่
    int is_start_of_word; 

    i = 0;
    is_start_of_word = 1; // เริ่มต้นที่ 1 เพราะอักขระแรกของสตริงถือเป็นจุดเริ่มต้นของคำ

    while (str[i] != '\0')
    {
        if (ft_is_alphanumeric(str[i])) // ตรวจสอบว่าอักขระเป็นตัวอักษรหรือตัวเลข
        {
            if (is_start_of_word) // ถ้าเป็นจุดเริ่มต้นของคำ
            {
                str[i] = ft_to_upper(str[i]); // แปลงเป็นตัวพิมพ์ใหญ่
            }
            else // ถ้าไม่ใช่จุดเริ่มต้นของคำ (อยู่ระหว่างคำ)
            {
                str[i] = ft_to_lower(str[i]); // แปลงเป็นตัวพิมพ์เล็ก
            }
            is_start_of_word = 0; // ตั้งค่าเป็น false เพราะตอนนี้อยู่ในคำแล้ว
        }
        else // ถ้าอักขระปัจจุบันไม่ใช่ตัวอักษรหรือตัวเลข (เป็นตัวคั่นคำ)
        {
            is_start_of_word = 1; // ตั้งค่าเป็น true เพื่อบอกว่าอักขระถัดไปอาจเป็นคำใหม่
        }
        i++;
    }
    return (str);
}